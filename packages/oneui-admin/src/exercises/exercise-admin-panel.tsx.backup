/**
 * Exercise Admin Panel
 *
 * Pannello admin per gestione esercizi - Refactored
 * Uses new Catalog Design System components.
 */

'use client';

import { useState, useMemo, useCallback, useEffect, type ReactNode } from 'react';
import Image from 'next/image';
import { useDebounce } from '@onecoach/hooks/use-debounce';
import { Edit, Trash2, ShieldCheck, ShieldX } from 'lucide-react';
import {
  CatalogHeader,
  CatalogGrid,
  ResourceCard,
  GlassToolbar,
  GlassTable,
  Combobox,
  type GlassTableColumn,
} from '@onecoach/ui';
import type { LocalizedExercise } from '@onecoach/lib-exercise';
import { ExerciseApprovalStatus } from '@onecoach/types/client';

// DEBUG: Check which import is undefined
console.log('[DEBUG] CatalogHeader:', typeof CatalogHeader);
console.log('[DEBUG] CatalogGrid:', typeof CatalogGrid);
console.log('[DEBUG] ResourceCard:', typeof ResourceCard);
console.log('[DEBUG] GlassToolbar:', typeof GlassToolbar);
console.log('[DEBUG] GlassTable:', typeof GlassTable);
console.log('[DEBUG] Combobox:', typeof Combobox);

import type { FilterStatus } from '@onecoach/types';
import { useExercises, useBatchExerciseOperations } from '@onecoach/lib-api/hooks';
import {
  useExerciseFilters,
  useExerciseSelection,
  useMuscles,
} from '@onecoach/features/exercise/hooks';
import { ExerciseFormModal } from './exercise-form-modal';
import { ExerciseImportModal } from './exercise-import-modal';
import { ExerciseAiModal } from './exercise-ai-modal';
import { ExerciseDetailDrawer } from './exercise-detail-drawer';
import { ExercisePagination } from './exercise-pagination';
import { ExerciseBulkActions } from './exercise-bulk-actions';
import { DEFAULT_PAGE_SIZE } from './exercise-constants';
import type { ExercisesResponse } from '@onecoach/lib-api';
import { useAdminExercisesRealtime } from '@/hooks/realtime';
import { sanitizeImageUrl } from '@onecoach/lib-shared/utils/image-url-sanitizer';

// DEBUG: Check local component imports
console.log('[DEBUG LOCAL] ExerciseFormModal:', typeof ExerciseFormModal);
console.log('[DEBUG LOCAL] ExerciseImportModal:', typeof ExerciseImportModal);
console.log('[DEBUG LOCAL] ExerciseAiModal:', typeof ExerciseAiModal);
console.log('[DEBUG LOCAL] ExerciseDetailDrawer:', typeof ExerciseDetailDrawer);
console.log('[DEBUG LOCAL] ExercisePagination:', typeof ExercisePagination);
console.log('[DEBUG LOCAL] ExerciseBulkActions:', typeof ExerciseBulkActions);


type LocalizedExerciseIndexed = LocalizedExercise & { [key: string]: unknown };

// SSOT: Usa direttamente ExercisesResponse indicizzato
interface ExercisesAdminPanelProps {
  initialData: ExercisesResponse<LocalizedExerciseIndexed> & {
    page: number;
    pageSize: number;
    total: number;
  };
}

export function ExercisesAdminPanel({ initialData }: ExercisesAdminPanelProps) {
  // Abilita Realtime sync per esercizi admin
  useAdminExercisesRealtime();

  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showImportModal, setShowImportModal] = useState(false);
  const [showAiModal, setShowAiModal] = useState(false);
  const [editExercise, setEditExercise] = useState<LocalizedExercise | null>(null);
  const [detailExercise, setDetailExercise] = useState<LocalizedExercise | null>(null);
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('list'); // Default to list for table view

  const filters = useExerciseFilters(initialData.page);
  const batchOperations = useBatchExerciseOperations();

  // Fetch muscles for filter
  const { muscles, isLoading: musclesLoading } = useMuscles();

  // Debounce per la ricerca - evita fetch ad ogni carattere digitato
  const debouncedSearchValue = useDebounce(filters.searchValue, 400);

  // Query params memoizzati
  const fetchParams = filters.getFetchParams();
  const queryParams = useMemo(
    () => ({
      page: filters.page,
      pageSize: DEFAULT_PAGE_SIZE,
      search:
        debouncedSearchValue && debouncedSearchValue.trim()
          ? debouncedSearchValue.trim()
          : undefined,
      approvalStatus: filters.statusFilter !== 'ALL' ? (filters.statusFilter as string) : undefined,
      includeTranslations: true,
      includeUnapproved: true,
      exerciseTypeId: fetchParams.exerciseTypeId,
      equipmentIds: fetchParams.equipmentIds,
      bodyPartIds: fetchParams.bodyPartIds,
      muscleIds: fetchParams.muscleIds,
    }),
    [
      filters.page,
      debouncedSearchValue,
      filters.statusFilter,
      fetchParams.exerciseTypeId,
      fetchParams.equipmentIds,
      fetchParams.bodyPartIds,
      fetchParams.muscleIds,
    ]
  );

  // Reset pagina quando cambiano i filtri
  useEffect(() => {
    if (filters.page !== 1) {
      filters.setPage(1);
    }
  }, [
    debouncedSearchValue,
    filters.statusFilter,
    fetchParams.exerciseTypeId,
    fetchParams.equipmentIds,
    fetchParams.bodyPartIds,
    fetchParams.muscleIds,
    filters,
  ]);

  // IMPORTANTE: Passa initialData solo per la prima pagina (page === 1) E se non ci sono filtri attivi
  // Se ci sono filtri, initialData (che contiene la lista completa non filtrata) non è valido
  const hasActiveFilters =
    filters.searchValue !== '' ||
    filters.statusFilter !== 'ALL' ||
    (fetchParams.muscleIds?.length ?? 0) > 0 ||
    (fetchParams.bodyPartIds?.length ?? 0) > 0 ||
    (fetchParams.equipmentIds?.length ?? 0) > 0 ||
    fetchParams.exerciseTypeId !== undefined;

  const shouldUseInitialData = filters.page === 1 && !hasActiveFilters && initialData !== null;

  type ExtendedExercise = LocalizedExercise & {
    id: string;
    name?: string;
    description?: string;
    category?: string;
    muscleGroups?: string[];
    equipment?: string[];
    [key: string]: unknown;
  };

  const {
    data: exercisesResponse,
    isLoading,
    refetch,
  } = useExercises<ExtendedExercise>(
    queryParams,
    shouldUseInitialData ? (initialData as ExercisesResponse<ExtendedExercise>) : undefined
  );

  const exercises = useMemo<LocalizedExercise[]>(
    () => (exercisesResponse?.data as LocalizedExercise[] | undefined) || [],
    [exercisesResponse?.data]
  );
  const total = exercisesResponse?.total ?? 0;
  const page = exercisesResponse?.page ?? filters.page;

  const exerciseSelection = useExerciseSelection(exercises);

  const approvedCount = useMemo(
    () =>
      exercises.filter((exercise) => exercise.approvalStatus === ExerciseApprovalStatus.APPROVED)
        .length,
    [exercises]
  );

  const pendingCount = useMemo(
    () =>
      exercises.filter((exercise) => exercise.approvalStatus === ExerciseApprovalStatus.PENDING)
        .length,
    [exercises]
  );

  const stats = useMemo(
    () => [
      { label: 'Totale', value: total },
      { label: 'Approvati', value: approvedCount },
      { label: 'In Attesa', value: pendingCount },
    ],
    [total, approvedCount, pendingCount]
  );

  const handleApprove = useCallback(
    async (id: string, status: ExerciseApprovalStatus) => {
      try {
        const action = status === ExerciseApprovalStatus.APPROVED ? 'approve' : 'reject';
        await batchOperations.mutateAsync({ action, ids: [id] });
      } catch (error: unknown) {
        const { dialog } = await import('@onecoach/lib-shared/utils/dialog-global');
        await dialog.error(error instanceof Error ? error.message : "Errore durante l'operazione");
      }
    },
    [batchOperations]
  );

  const handleDelete = useCallback(
    async (id: string) => {
      const { dialog } = await import('@onecoach/lib-shared/utils/dialog-global');
      const confirmed = await dialog.confirm('Sei sicuro di voler eliminare questo esercizio?');
      if (!confirmed) return;

      try {
        await batchOperations.mutateAsync({ action: 'delete', ids: [id] });
      } catch (error: unknown) {
        const { dialog: dialogUtil } = await import('@onecoach/lib-shared/utils/dialog-global');
        await dialogUtil.error(
          error instanceof Error ? error.message : "Errore durante l'eliminazione"
        );
      }
    },
    [batchOperations]
  );

  const handlePageChange = useCallback(
    (direction: 'prev' | 'next') => {
      const newPage = direction === 'prev' ? page - 1 : page + 1;
      filters.setPage(newPage);
      window.scrollTo({ top: 0, behavior: 'smooth' });
    },
    [page, filters]
  );

  // Prepare filter options for Comboboxes
  const statusOptions = [
    { label: 'Tutti gli stati', value: 'ALL' },
    { label: 'Approvati', value: ExerciseApprovalStatus.APPROVED },
    { label: 'In Attesa', value: ExerciseApprovalStatus.PENDING },
    { label: 'Rifiutati', value: ExerciseApprovalStatus.REJECTED },
  ];

  const muscleOptions = useMemo(
    () => muscles.map((m: { id: string; name: string }) => ({ label: m.name, value: m.id })),
    [muscles]
  );

  // Table Columns configuration
  const columns: GlassTableColumn<LocalizedExercise>[] = [
    {
      header: 'Esercizio',
      cell: (exercise) => {
        const imageUrl = sanitizeImageUrl(exercise.imageUrl || exercise.videoUrl);
        return (
          <div className="flex items-center gap-3">
            <div className="h-10 w-10 shrink-0 overflow-hidden rounded-lg bg-neutral-100 dark:bg-neutral-800">
              {imageUrl && (
                <Image
                  src={imageUrl}
                  alt={exercise.slug}
                  width={40}
                  height={40}
                  className="h-full w-full object-cover"
                />
              )}
            </div>
            <div>
              <div className="font-medium text-neutral-900 dark:text-white">
                {exercise.translation?.name || exercise.slug}
              </div>
              <div className="text-xs text-neutral-500">{exercise.exerciseTypeName}</div>
            </div>
          </div>
        );
      },
    },
    {
      header: 'Muscoli',
      cell: (exercise) => (
        <div className="flex flex-wrap gap-1">
          {exercise.muscles?.slice(0, 2).map((m: { id: string; name: string }) => (
            <span
              key={m.id}
              className="inline-flex rounded-full bg-blue-50 px-2 py-0.5 text-xs font-medium text-blue-700 dark:bg-blue-900/30 dark:text-blue-300"
            >
              {m.name}
            </span>
          ))}
          {(exercise.muscles?.length || 0) > 2 && (
            <span className="text-xs text-neutral-500">+{exercise.muscles!.length - 2}</span>
          )}
        </div>
      ),
    },
    {
      header: 'Difficoltà',
      cell: (exercise) => {
        const difficulty = (exercise as { difficulty?: string | null }).difficulty;
        return (
          <span className="text-sm text-neutral-600 dark:text-neutral-400">
            {difficulty ?? '-'}
          </span>
        );
      },
    },
    {
      header: 'Stato',
      cell: (exercise) => {
        const status = exercise.approvalStatus || 'PENDING';
        const colors = {
          APPROVED: 'bg-emerald-50 text-emerald-700 dark:bg-emerald-900/30 dark:text-emerald-300',
          PENDING: 'bg-amber-50 text-amber-700 dark:bg-amber-900/30 dark:text-amber-300',
          REJECTED: 'bg-red-50 text-red-700 dark:bg-red-900/30 dark:text-red-300',
        } as const;
        // @ts-expect-error - status type might not match exact keys but logic is safe
        const colorClass = colors[status] || colors.PENDING;

        return (
          <span
            className={`inline-flex rounded-full px-2.5 py-0.5 text-xs font-medium ${colorClass}`}
          >
            {status}
          </span>
        );
      },
    },
    {
      header: 'Azioni',
      className: 'text-right',
      cell: (exercise) => (
        <div className="flex justify-end gap-2">
          <button
            onClick={(e: React.MouseEvent<HTMLElement>) => {
              e.stopPropagation();
              setEditExercise(exercise);
            }}
            className="rounded p-1 text-neutral-500 hover:bg-neutral-100 hover:text-neutral-900 dark:hover:bg-neutral-800 dark:hover:text-white"
          >
            <Edit size={16} />
          </button>
          {exercise.approvalStatus === ExerciseApprovalStatus.PENDING && (
            <button
              onClick={(e: React.MouseEvent<HTMLElement>) => {
                e.stopPropagation();
                handleApprove(exercise.id, ExerciseApprovalStatus.APPROVED);
              }}
              className="rounded p-1 text-emerald-500 hover:bg-emerald-50 hover:text-emerald-700 dark:hover:bg-emerald-900/30"
              title="Approva"
            >
              <ShieldCheck size={16} />
            </button>
          )}
          <button
            onClick={(e: React.MouseEvent<HTMLElement>) => {
              e.stopPropagation();
              handleDelete(exercise.id);
            }}
            className="rounded p-1 text-neutral-500 hover:bg-red-50 hover:text-red-600 dark:hover:bg-red-900/30 dark:hover:text-red-400"
          >
            <Trash2 size={16} />
          </button>
        </div>
      ),
    },
  ];

  return (
    <div className="container mx-auto max-w-[1600px] px-4 py-8">
      <CatalogHeader
        title="Catalogo Esercizi"
        description="Gestisci il database centralizzato degli esercizi."
        stats={stats}
        onAdd={() => setShowCreateModal(true)}
        addLabel="Nuovo Esercizio"
      />

      {/* New Glass Toolbar with Filters */}
      <GlassToolbar
        searchQuery={filters.searchValue}
        onSearchChange={filters.setSearchValue}
        viewMode={viewMode}
        onViewModeChange={setViewMode}
      >
        <Combobox
          options={statusOptions}
          value={filters.statusFilter}
          onChange={(val: string | string[]) => {
            if (typeof val === 'string') {
              filters.setStatusFilter(val as FilterStatus);
            }
          }}
          placeholder="Filtra per stato"
          className="w-[180px]"
        />
        <Combobox
          options={muscleOptions}
          value={filters.getFetchParams().muscleIds || []}
          onChange={(val: string | string[]) => {
            const nextValue = Array.isArray(val) ? val : [val];
            filters.setMuscleIds(nextValue);
          }}
          placeholder="Gruppo Muscolare"
          searchPlaceholder="Cerca muscolo..."
          multiple
          className="w-[220px]"
          disabled={musclesLoading}
        />
      </GlassToolbar>

      {/* Bulk Actions */}
      {exerciseSelection.selectCount > 0 && (
        <ExerciseBulkActions
          selectedCount={exerciseSelection.selectCount}
          totalCount={total}
          isAllSelected={exerciseSelection.isAllSelected}
          onSelectAll={exerciseSelection.toggleSelectAll}
          onApprove={async () => {
            const ids = Array.from(exerciseSelection.selectedIds) as string[];
            try {
              await batchOperations.mutateAsync({ action: 'approve', ids });
              exerciseSelection.clearSelection();
            } catch (error: unknown) {
              const { dialog } = await import('@onecoach/lib-shared/utils/dialog-global');
              await dialog.alert(
                error instanceof Error ? error.message : "Errore durante l'approvazione"
              );
            }
          }}
          onReject={async () => {
            const ids = Array.from(exerciseSelection.selectedIds) as string[];
            try {
              await batchOperations.mutateAsync({ action: 'reject', ids });
              exerciseSelection.clearSelection();
            } catch (error: unknown) {
              const { dialog } = await import('@onecoach/lib-shared/utils/dialog-global');
              await dialog.alert(
                error instanceof Error ? error.message : 'Errore durante il rifiuto'
              );
            }
          }}
          onDelete={async () => {
            const ids = Array.from(exerciseSelection.selectedIds) as string[];
            const { dialog } = await import('@onecoach/lib-shared/utils/dialog-global');
            const confirmed = await dialog.confirm(
              `Eliminare ${ids.length} elemento${ids.length > 1 ? 'i' : ''} selezionato${ids.length > 1 ? 'i' : ''}?`
            );
            if (!confirmed) return;
            try {
              await batchOperations.mutateAsync({ action: 'delete', ids });
              exerciseSelection.clearSelection();
            } catch (error: unknown) {
              await dialog.alert(
                error instanceof Error ? error.message : "Errore durante l'eliminazione"
              );
            }
          }}
          isLoading={batchOperations.isPending}
        />
      )}

      {/* Content - Conditional Rendering based on View Mode */}
      {viewMode === 'list' ? (
        <GlassTable
          data={exercises}
          columns={columns}
          isLoading={isLoading}
          keyExtractor={(item) => item.id}
          onRowClick={(item) => setDetailExercise(item)}
          className="mb-8"
          selectedIds={exerciseSelection.selectedIds}
          onSelectRow={exerciseSelection.toggleSelect}
          onSelectAll={exerciseSelection.toggleSelectAll}
          isAllSelected={exerciseSelection.isAllSelected}
        />
      ) : (
        <CatalogGrid
          isLoading={isLoading}
          viewMode="grid"
          emptyState={<div className="text-center text-neutral-500">Nessun esercizio trovato.</div>}
        >
          {exercises.map((exercise) => {
            const muscleBadges = Array.isArray(exercise.muscles)
              ? (exercise.muscles as Array<{ name?: string }>)
                  .slice(0, 3)
                  .map((m) => m?.name ?? '')
                  .filter((name): name is string => Boolean(name))
              : [];
            const exerciseStats: Array<{ label: string; value: string }> = [];
            const difficulty = (exercise as { difficulty?: string | null }).difficulty;
            if (difficulty) {
              exerciseStats.push({ label: 'Difficoltà', value: difficulty });
            }

            type CardAction = {
              label: string;
              icon: ReactNode;
              onClick: () => void;
              variant?: 'default' | 'destructive' | 'outline';
            };

            const actions: CardAction[] = [
              {
                label: 'Modifica',
                icon: <Edit size={16} />,
                onClick: () => setEditExercise(exercise),
                variant: 'default',
              },
              {
                label: 'Elimina',
                icon: <Trash2 size={16} />,
                onClick: () => handleDelete(exercise.id),
                variant: 'destructive',
              },
            ];

            if (exercise.approvalStatus === ExerciseApprovalStatus.PENDING) {
              actions.unshift(
                {
                  label: 'Approva',
                  icon: <ShieldCheck size={16} />,
                  onClick: () => handleApprove(exercise.id, ExerciseApprovalStatus.APPROVED),
                  variant: 'default',
                },
                {
                  label: 'Rifiuta',
                  icon: <ShieldX size={16} />,
                  onClick: () => handleApprove(exercise.id, ExerciseApprovalStatus.REJECTED),
                  variant: 'destructive',
                }
              );
            }

            const sanitizedImageUrl =
              sanitizeImageUrl(exercise.imageUrl) || sanitizeImageUrl(exercise.videoUrl);
            const status =
              typeof exercise.approvalStatus === 'string'
                ? exercise.approvalStatus.toLowerCase()
                : 'pending';

            return (
              <ResourceCard
                key={exercise.id}
                title={exercise.translation?.name || exercise.slug || 'Senza nome'}
                subtitle={exercise.exerciseTypeName ?? undefined}
                imageSrc={sanitizedImageUrl || undefined}
                status={status}
                badges={muscleBadges}
                stats={exerciseStats}
                onClick={() => setDetailExercise(exercise)}
                actions={actions}
                isSelected={exerciseSelection.selectedIds.has(exercise.id) || false}
                onSelect={() => exerciseSelection.toggleSelect(exercise.id)}
              />
            );
          })}
        </CatalogGrid>
      )}

      {/* Pagination */}
      {total > DEFAULT_PAGE_SIZE && (
        <div className="mt-8">
          <ExercisePagination
            page={page}
            totalPages={Math.ceil(total / DEFAULT_PAGE_SIZE)}
            total={total}
            onPageChange={handlePageChange}
            isLoading={isLoading}
          />
        </div>
      )}

      {/* Modals */}
      {showCreateModal && (
        <ExerciseFormModal
          isOpen={showCreateModal}
          mode="create"
          onClose={() => setShowCreateModal(false)}
          onSuccess={() => {
            setShowCreateModal(false);
            refetch();
          }}
        />
      )}

      {editExercise && (
        <ExerciseFormModal
          isOpen={!!editExercise}
          mode="edit"
          exerciseId={editExercise.id}
          onClose={() => setEditExercise(null)}
          onSuccess={() => {
            setEditExercise(null);
            refetch();
          }}
        />
      )}

      {showImportModal && (
        <ExerciseImportModal
          isOpen={showImportModal}
          onClose={() => setShowImportModal(false)}
          onSuccess={() => {
            setShowImportModal(false);
            refetch();
          }}
        />
      )}

      {showAiModal && (
        <ExerciseAiModal
          isOpen={showAiModal}
          onClose={() => setShowAiModal(false)}
          onSuccess={() => {
            setShowAiModal(false);
            refetch();
          }}
        />
      )}

      {detailExercise && (
        <ExerciseDetailDrawer
          exercise={detailExercise}
          isOpen={!!detailExercise}
          onClose={() => setDetailExercise(null)}
          onEdit={() => {
            setEditExercise(detailExercise);
            setDetailExercise(null);
          }}
          onApprove={(status) => handleApprove(detailExercise.id, status)}
          onDelete={() => handleDelete(detailExercise.id)}
        />
      )}
    </div>
  );
}
